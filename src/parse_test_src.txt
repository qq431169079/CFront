
parse_stmt_cxt_t *parse_stmt_init(char *input) { return parse_exp_init(input); }
void parse_stmt_free(parse_stmt_cxt_t *cxt) { parse_exp_free(cxt); }

// Return a labeled statement
token_t *parse_lbl_stmt(parse_stmt_cxt_t *cxt, token_type_t type) {
  if(type == T_IDENT) {
    token_t *token = token_alloc_type(T_LBL_STMT);
    ast_append_child(token, token_get_next(cxt->token_cxt));
    if(!token_consume_type(cxt->token_cxt, T_COLON)) assert(0); // Caller guarantees this
    return ast_append_child(token, parse_stmt(cxt));
  }  
  //token_t *token = token_get_next(cxt->token_cxt);
  if(type == T_CASE) ast_append_child(token, parse_exp(cxt, PARSE_EXP_NOCOLON));
  if(!token_consume_type(cxt->token_cxt, T_COLON))
    error_row_col_exit(token->offset, "Expecting \':\' for \"%s\" statement\n", token_symstr(token->type));
  return ast_append_child(token, parse_stmt(cxt));
}

// Returns an expression statement
token_t *parse_exp_stmt(parse_stmt_cxt_t *cxt) {
  token_t *token = ast_append_child(token_alloc_type(T_EXP_STMT), parse_exp(cxt, PARSE_EXP_ALLOWALL));
  if(!token_consume_type(cxt->token_cxt, T_SEMICOLON))
    error_row_col_exit(cxt->token_cxt->s, "Expecting \';\' after expression statement\n");
  return token;
}
